\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8,latin1]{inputenc}
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `spatial.tools'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\item[Maintainer]\AsIs{Jonathan Asher Greenberg }\email{spatial-tools@estarcion.net}\AsIs{}
\item[License]\AsIs{GPL (>= 2)}
\item[Title]\AsIs{R functions for working with spatial data.}
\item[Type]\AsIs{Package}
\item[LazyLoad]\AsIs{yes}
\item[Author]\AsIs{Jonathan Asher Greenberg}
\item[Description]\AsIs{R functions for working with spatial data.}
\item[Version]\AsIs{0.9.1}
\item[Date]\AsIs{2013-02-23}
\item[Depends]\AsIs{raster, rgdal, sp, mmap, abind, snowfall, foreach, doSNOW, R
(>= 2.15.2)}
\item[Collate]\AsIs{'spatial\_sync\_vector.R' 'tahoe\_highrez\_data.R'
'tahoe\_highrez\_training\_data.R' 'tahoe\_lidar\_bareearth\_data.R'
'tahoe\_lidar\_highesthit\_data.R' 'remove\_file\_extension.R'
'build\_raster\_header.R' 'fix\_extent.R' 'add\_leading\_zeroes.R'
'spatial\_sync\_raster.R' 'binary\_image\_write.R' 'focal\_hpc.R'
'getValuesBlock\_enhanced.R' 'which\_simple.R'
'subset\_raster\_by\_names.R' 'sfQuickInit.R' 'raster\_to\_tile.R'
'create\_blank\_raster.R' 'sfQuickStop.R'
'get\_gdal\_installation.R'}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{add\_leading\_zeroes}{Add Leading Zeroes to a Numeric Vector}{add.Rul.leading.Rul.zeroes}
\keyword{format}{add\_leading\_zeroes}
%
\begin{Description}\relax
Appends leading zeroes to a vector of numbers based on a
string length or a maximum number.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  add_leading_zeroes(number, number_length, max_number)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{number}] A numeric vector.

\item[\code{number\_length}] The length of the output string.

\item[\code{max\_number}] A number to base the length of the
output string on.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A character vector.
\end{Value}
%
\begin{Author}\relax
Jonathan A. Greenberg
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
x=c(1:10)
add_leading_zeroes(x,number_length=4)
add_leading_zeroes(x,max_number=10000)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{binary\_image\_write}{Writes image data to a flat binary file using col/row/band positioning.}{binary.Rul.image.Rul.write}
\keyword{mmap}{binary\_image\_write}
%
\begin{Description}\relax
Writes image data to a flat binary file using
col/row/band positioning.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  binary_image_write(filename, mode = real64(), image_dims,
    interleave = "BSQ", data, data_position)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{filename}] Character.  The path and filename of a
"blank" binary file to store the image data.

\item[\code{mode}] The mode of data on disk.  Defaults to
real64() (double precision floating point).

\item[\code{image\_dims}] Vector. Vector of length(image\_dims)==3
representing the number of columns, rows and bands in the
output image.

\item[\code{interleave}] Character. The require output
interleave.  By default is "BSQ". OTHER INTERLEAVES
CURRENTLY UNSUPPORTED.

\item[\code{data}] Vector, matrix, array, or other data source
which is coercible to a vector. This is the data to be
written to the image.

\item[\code{data\_position}] List. A length==3 list, containing
the column, row, and band positions ranges to write the
output data.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
%
\begin{Author}\relax
Jonathan A. Greenberg
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{mmap}{mmap}},\code{\LinkA{create\_blank\_raster}{create.Rul.blank.Rul.raster}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
tahoe_highrez <- brick(system.file("external/tahoe_highrez.tif", package="spatial.tools"))
# Create a blank file using create_blank_raster
test_blank_file <- create_blank_raster(reference_raster=tahoe_highrez)
blank_raster <- brick(test_blank_file)
# It should be all 0s:
setMinMax(blank_raster)
# Write some ones to to the 100th line, columns 25 to 50, bands 1 and 3:
data_position <- list(25:50,100,c(1,3))
data1s <- array(1,dim=c(length(data_position[[1]]),length(data_position[[2]]),length(data_position[[3]])))
plot(raster(test_blank_file,layer=1))
binary_image_write(filename=test_blank_file,
	mode=real64(),image_dims=dim(tahoe_highrez),interleave="BSQ",
	data=data1s,data_position=data_position)
setMinMax(blank_raster)
plot(raster(blank_raster,layer=1))

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{build\_raster\_header}{Builds a raster header for a flat binary file.}{build.Rul.raster.Rul.header}
%
\begin{Description}\relax
Builds a raster header for a flat binary file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  build_raster_header(x_filename, reference_raster,
    out_nlayers, dataType = "FLT8S", format = "raster",
    bandorder = "BIP", verbose = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x\_filename}] Character. The filename of the input
binary file.

\item[\code{reference\_raster}] Raster*. A Raster* object
containing the header information to be used.

\item[\code{out\_nlayers}] Numeric. The number of layers in the
flat binary file (defaults to
nlayers(reference\_raster)).

\item[\code{dataType}] Character. The dataType of the flat
binary file.  See ?dataType for available datatypes.
Default is 'FLT8S'.

\item[\code{bandorder}] Character. The bandorder
('BIP','BIL','BSQ') of the file. Default is 'BIP'.

\item[\code{format}] Character. The format of the header.  See
?hdr for valid entries.  Default is 'raster'.  CURRENTLY
UNSUPPORTED.

\item[\code{verbose}] logical. Enable verbose execution? Default
is FALSE.
\end{ldescription}
\end{Arguments}
%
\begin{Author}\relax
Jonathan A. Greenberg and Robert Hijimans
(\email{spatial.tools@estarcion.net})
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{hdr}{hdr}},\code{\LinkA{dataType}{dataType}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# TODO
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{create\_blank\_raster}{Create an empty raster and header.}{create.Rul.blank.Rul.raster}
%
\begin{Description}\relax
This function creates an arbitrarily large raster as a
flat binary file with (optionally) a proper header for
use with other functions.  This should create the blank
files very quickly, as it is using some OS tricks to
carve out a block of space rather than writing a bunch of
0s to disk sequentially.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  create_blank_raster(filename = NULL, format = "raster",
    dataType = "FLT8S", bandorder = "BSQ", nrow = NULL,
    ncol = NULL, nlayers = NULL, create_header = TRUE,
    reference_raster = NULL, return_filename = TRUE,
    overwrite = FALSE, verbose = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{filename}] Character. The output base filename of
the blank file.  Will use tempfile() if nothing is
provided.

\item[\code{format}] Character.  Output format.  Currently only
supports "raster".

\item[\code{dataType}] Character.  Output number type.  See
?dataType Currently only supports "FLT8S".

\item[\code{bandorder}] Character.  Output band interleave.
Currently only supports "BSQ".

\item[\code{nrow}] Numeric. Number of rows of the output raster.
Defaults to nrow(reference\_raster).

\item[\code{ncol}] Numeric. Number of columns of the output
raster. Defaults to ncol(reference\_raster).

\item[\code{nlayers}] Numeric. Number of layers of the output
raster Defaults to nlayer(reference\_raster).

\item[\code{create\_header}] Logical. Create a properly formatted
header for the blank file?

\item[\code{reference\_raster}] Raster*. Reference raster to
derive other information, e.g. resolution, projection,
datum.

\item[\code{return\_filename}] Logical. Return filename of the
binary file (if TRUE, default) or the Raster* itself (if
FALSE).

\item[\code{overwrite}] Logical. Overwrite an existing file with
the same name?

\item[\code{verbose}] Logical. Enable verbose execution? Default
is FALSE.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
create\_blank\_raster is designed to quickly create a
binary file of the appropriate size using tricks with
seek()/writeBin(). A large file can be created in a
fraction of a second using this function. This file
could, for example, be used with mmap to realize
asynchronous or, OS permitting, parallel writes to a
single file.  Note that setMinMax are NOT performed on
the output file (to save time), so on some systems you
may see a warning.

Binary files of this type are used by a number of raster
formats, including raster and ENVI.
\end{Details}
%
\begin{Value}
A character vector (return\_filename==TRUE) or as Raster*
object (return\_filename==TRUE)
\end{Value}
%
\begin{Author}\relax
Jonathan A. Greenberg
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
tahoe_highrez <- brick(system.file("external/tahoe_highrez.tif", package="spatial.tools"))
test_blank_file <- create_blank_raster(reference_raster=tahoe_highrez)
file.info(test_blank_file)
test_blank_raster <- create_blank_raster(reference_raster=tahoe_highrez,return_filename=FALSE)
test_blank_raster

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fix\_extent}{Forces a list of Raster*s to all have the same extent.}{fix.Rul.extent}
%
\begin{Description}\relax
Forces a list of Raster*s to all have the same extent.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  fix_extent(extent_reference, broken_extents)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{extent\_reference}] Raster*. A Raster* object that
will provide the extent to all the other Raster*s.  If
unassigned, will assume it is the first Raster* in the
broken\_extents list.

\item[\code{broken\_extents}] list of Raster* objects. Raster*
objects that will be coerced to the extent\_reference's
extent.
\end{ldescription}
\end{Arguments}
%
\begin{Author}\relax
Jonathan A. Greenberg
(\email{spatial.tools@estarcion.net})
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{extent}{extent}},\code{\LinkA{stack}{stack}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{focal\_hpc}{Engine for performing fast, easy to develop pixel and focal raster calculations with parallel processing capability.}{focal.Rul.hpc}
%
\begin{Description}\relax
Engine for performing fast, easy to develop pixel and
focal raster calculations with parallel processing
capability.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  focal_hpc(x, fun, args = NULL, window_dims = c(1, 1),
    window_center = c(ceiling(window_dims[1]/2), ceiling(window_dims[2]/2)),
    filename = NULL, overwrite = FALSE,
    outformat = "raster", chunk_format = "array",
    minblocks = 1, verbose = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Raster*. A Raster* used as the input into the
function.  Multiple inputs should be stacked together.

\item[\code{fun}] function. A focal function to be applied to
the image. See Details.

\item[\code{args}] list. Arguments to pass to the function (see
?mapply).

\item[\code{window\_dims}] Vector. The size of a processing
window in col x row order.  Be default, a single pixel
(c(1,1).

\item[\code{window\_center}] Vector. The local coordinate of the
center of a processing window.  By default the middle of
the processing window.  UNSUPPORTED.

\item[\code{chunk\_format}] Character. The format to send the
chunk to the function.  Can be "array" (default) or
"raster".

\item[\code{minblocks}] Numeric. The minimum number of chunks to
divide the raster into for processing.  Defaults to 1.

\item[\code{filename}] character. Filename of the output
raster.

\item[\code{outformat}] character. Outformat of the raster. Must
be a format usable by hdr(). Default is 'raster'.
CURRENTLY UNSUPPORTED.

\item[\code{overwrite}] logical. Allow files to be overwritten?
Default is FALSE.

\item[\code{verbose}] logical. Enable verbose execution? Default
is FALSE.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
focal\_hpc is designed to execute a function on a Raster*
object using foreach, to achieve parallel reads,
executions and writes. Parallel random writes are
achieved through the use of mmap, so individual image
chunks can finish and write their outputs without having
to wait for all nodes in the cluster to finish and then
perform sequential writing.  On Windows systems, random
writes are possible but apparently not parallel writes.
focal\_hpc solves this by trying to write to a portion of
the image file, and if it finds an error (a race
condition occurs), it will simply retry the writes until
it successfully finishes.  On a Linux system, truly
parallel writes should be possible.

focal\_hpc operates in two modes, which have different
input and outputs to the function:

Pixel based processing:

1) If chunk\_format=="array" (default), the input to the
function should assume an array of dimensions x,y,z where
x = the number of columns in a chunk, y = the number of
rows in the chunk, and z = the number of bands in the
chunk.  If chunk\_format=="raster", the input to the
function will be a raster subset. Note that we are
ordering the array using standards for geographic data,
(columns, rows, bands), not how R usually thinks of
arrays (rows, columns, bands).

2) The output of the function should always be an array
with the x and y dimensions matching the input, and an
arbitrary number of band outputs.  Remember to order the
dimensions as columns, rows, bands (x,y,z).

Local window processing:

1) The function should be written to process a SINGLE
window at a time, given the dimensions of window\_dims, so
the input to the function should assume a window of
dimensions window\_dims with a local center defined by
window\_center.  As with before, the input can be passed
to the function as an array (suggested) or a small
raster.

2) The output should be a single pixel value, so can
either be a single value, or a vector (which is assumed
to be multiple bands of a single pixel).

The speed of the execution when running in parallel will
vary based on the specific setup, and may, indeed, be
slower than a sequential execution (e.g. with calc() ),
particularly on smaller files.  Note that by simply
running sfQuickStop(), focal\_hpc will run in sequential
mode.
\end{Details}
%
\begin{Author}\relax
Jonathan A. Greenberg
(\email{spatial.tools@estarcion.net})
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{foreach}{foreach}}, \code{\LinkA{mmap}{mmap}},
\code{\LinkA{dataType}{dataType}}, \code{\LinkA{hdr}{hdr}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
 tahoe_highrez <- brick(system.file("external/tahoe_highrez.tif", package="spatial.tools"))
# Pixel-based processing:
# Uncomment sfQuickInit()/sfQuickStop() to (potentially) speed this up:
# sfQuickInit()
	ndvi_function <- function(x,...)
	{
		# Note that x is received by the function as a 3-d array:
		red_band <- x[,,2]
		nir_band <- x[,,3]
		ndvi <- (nir_band - red_band)/(nir_band + red_band)
		# The output of the function should also be a 3-d array,
		# even if it is a single band:
		ndvi <- array(ndvi,dim=c(dim(x)[1],dim(x)[2],1))
		return(ndvi)
	}
 tahoe_ndvi <- focal_hpc(x=tahoe_highrez,fun=ndvi_function)
# sfQuickStop()

# Focal-based processing:
local_smoother <- function(x,...)
{
 # Assumes a 3-d array representing
	# a single local window, and return
 # a single value or a vector of values.
	smoothed <- apply(x,3,mean)
	return(smoothed)
}
# Apply the function to a 3x3 window:
# sfQuickInit()
tahoe_3x3_smoothed <- focal_hpc(x=tahoe_highrez,fun=local_smoother,window_dims=c(3,3))
# sfQuickStop()

# Example with 7 x 7 window in parallel mode:
sfQuickInit()
tahoe_7x7_smoothed <- focal_hpc(x=tahoe_highrez,fun=local_smoother,window_dims=c(7,7))
sfQuickStop()

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getValuesBlock\_enhanced}{Easier-to-use function for grabbing a block of data out of a Raster*.}{getValuesBlock.Rul.enhanced}
%
\begin{Description}\relax
Easier-to-use function for grabbing a block of data out
of a Raster*.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  getValuesBlock_enhanced(x, r1 = 1, r2 = nrow(x), c1 = 1,
    c2 = ncol(x), format = "array", ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Raster* Some input Raster* object.

\item[\code{r1}] Numeric. The start row of the chunk.

\item[\code{r2}] Numeric. The end row of the chunk.

\item[\code{c1}] Numeric. The start column of the chunk.

\item[\code{c2}] Numeric The end row of the chunk.

\item[\code{format}] Character. If "array" (default), the chunk
will be returned in a 3-d array with dimensions
representing column,row,and layer.  If "raster", the
chunk will be returned as a Raster* object.

\item[\code{...}] Other parameters.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An array or raster object.
\end{Value}
%
\begin{Author}\relax
Jonathan A. Greenberg
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{getValues}{getValues}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
tahoe_highrez <- brick(system.file("external/tahoe_highrez.tif", package="spatial.tools"))
mychunk <- getValuesBlock_enhanced(tahoe_highrez,r1=100,r2=110,c1=20,c2=50)
class(mychunk)
dim(mychunk)
mychunk_raster <- getValuesBlock_enhanced(tahoe_highrez,r1=100,r2=110,c1=20,c2=50,format="raster")
mychunk_raster
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{remove\_file\_extension}{remove\_file\_extension}{remove.Rul.file.Rul.extension}
%
\begin{Description}\relax
Strips a file extension from a filename.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  remove_file_extension(filename,
    extension_delimiter = ".")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{filename}] Character. The input filename.

\item[\code{extension\_delimiter}] Character. The extension or
extension delimiter (default ".") to remove.
\end{ldescription}
\end{Arguments}
%
\begin{Author}\relax
Jonathan A. Greenberg \email{spatial.tools@estarcion.net}
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
myfilename="my.file.gri"
remove_file_extension(myfilename,".")
remove_file_extension(myfilename,".file.gri")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{sfQuickInit}{Quickly initializes a parallel snowfall cluster and registers it with foreach.}{sfQuickInit}
%
\begin{Description}\relax
Quickly initializes a parallel snowfall cluster and
registers it with foreach.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  sfQuickInit(cpus, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{cpus}] Number of cpus.  Will default to the max
available cpus.

\item[\code{...}] parameters to pass to sfInit()
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
(Even more) quickly start a snowfall cluster with maximum
available cpus, parallel = TRUE, and type = "SOCK" and
registers it with foreach.
\end{Details}
%
\begin{Author}\relax
Jonathan A. Greenberg
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{sfInit}{sfInit}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
sfQuickInit()
sfGetCluster()
sfQuickStop()

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{sfQuickStop}{Quickly stops a parallel snowfall cluster and deregisters it from foreach.}{sfQuickStop}
%
\begin{Description}\relax
Quickly stops a parallel snowfall cluster and deregisters
it from foreach.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  sfQuickStop(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] parameters to pass to sfStop()
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
(Even more) quickly stop a snowfall cluster and sets
foreach back to sequential mode via registerDoSEQ().
\end{Details}
%
\begin{Author}\relax
Jonathan A. Greenberg
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{sfInit}{sfInit}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
sfQuickInit()
sfGetCluster()
sfQuickStop()

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{spatial\_sync\_raster}{Spatially Sync Rasters}{spatial.Rul.sync.Rul.raster}
%
\begin{Description}\relax
Aligns ("syncs") a Raster to a reference Raster.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  spatial_sync_raster(unsynced, reference, method = "ngb",
    size_only = FALSE, raster_size, verbose = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{unsynced}] A Raster object to be aligned to the
reference raster.

\item[\code{reference}] A Raster object to be used as the
reference for syncing. Syncing will use the reference's
projection, resolution, and extent.

\item[\code{method}] Method used to compute values for the new
RasterLayer. Either 'ngb' (nearest neighbor) or
'bilinear' (bilinear interpolation).

\item[\code{verbose}] verbose=TRUE gives feedback on the process
(UNSUPPORTED AT PRESENT).

\item[\code{size\_only}] TODO

\item[\code{raster\_size}] TODO
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Uses bilinear or nearest neighbor resampling to align a
raster to the extent and projection of a reference raster
and match the resolution of the reference raster.  This
is helpful in preparing multiple files of different
projections, resolutions, extents, and rotations for
performing map algebra or change detection.
\end{Details}
%
\begin{Value}
Returns a RasterLayer, RasterBrick or RasterStack object
synced to the reference raster object.
\end{Value}
%
\begin{Author}\relax
Jonathan A. Greenberg
(\email{spatial.tools@estarcion.net})
\end{Author}
\inputencoding{utf8}
\HeaderA{spatial\_sync\_vector}{Matches a vector's projection to another vector or raster object's projection.}{spatial.Rul.sync.Rul.vector}
%
\begin{Description}\relax
Matches a vector's projection to another vector or raster
object's projection.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  spatial_sync_vector(unsynced, reference, verbose = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{unsynced}] The vector to be projected.

\item[\code{reference}] A raster or vector object who's
projection the unsynced will be matched to.

\item[\code{verbose}] Logical. Verbose logging?
\end{ldescription}
\end{Arguments}
%
\begin{Author}\relax
Jonathan A. Greenberg
(\email{spatial.tools@estarcion.net})
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
tahoe_highrez_training_points_utm <- readOGR(dsn=system.file("external", package="spatial.tools"),layer="tahoe_highrez_training_points_utm")
print(projection(tahoe_highrez_training_points_utm))
tahoe_lidar_bareearth <- raster(system.file("external/tahoe_lidar_bareearth.tif", package="spatial.tools"))
print(projection(tahoe_lidar_bareearth))
tahoe_highrez_training_points_utm_synced <- spatial_sync_vector(tahoe_highrez_training_points_utm,tahoe_lidar_bareearth)
print(projection(tahoe_highrez_training_points_utm_synced))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{subset\_raster\_by\_names}{Subsets a raster based on its layer names}{subset.Rul.raster.Rul.by.Rul.names}
%
\begin{Description}\relax
Subsets a raster based on its layer names
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  subset_raster_by_names(x, subset_names, allnames = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A Raster* object to be subsetted.

\item[\code{subset\_names}] Character. A vector of layer names to
use to subset the Raster*.

\item[\code{allnames}] Logical. Make sure all subset\_names are
contained by x?
\end{ldescription}
\end{Arguments}
%
\begin{Author}\relax
Jonathan A. Greenberg
(\email{spatial.tools@estarcion.net})
\end{Author}
\inputencoding{utf8}
\HeaderA{tahoe\_highrez.tif}{High resolution false color infrared image from the Lake Tahoe Basin.}{tahoe.Rul.highrez.tif}
\keyword{data}{tahoe\_highrez.tif}
\keyword{datasets}{tahoe\_highrez.tif}
%
\begin{Description}\relax
High resolution false color infrared image from the Lake
Tahoe Basin.
\end{Description}
%
\begin{Author}\relax
Jonathan A. Greenberg \email{spatial.tools@estarcion.net}
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
tahoe_highrez <- brick(system.file("external/tahoe_highrez.tif", package="spatial.tools"))
plotRGB(tahoe_highrez)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{tahoe\_highrez\_training}{Point and polygon files for use with spatial.tools}{tahoe.Rul.highrez.Rul.training}
\keyword{data}{tahoe\_highrez\_training}
\keyword{datasets}{tahoe\_highrez\_training}
%
\begin{Description}\relax
Point and polygon files for use with spatial.tools
\end{Description}
%
\begin{Author}\relax
Jonathan A. Greenberg \email{spatial.tools@estarcion.net}
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
tahoe_highrez_training_polygons <- readOGR(dsn=system.file("external", package="spatial.tools"),layer="tahoe_highrez_training")
spplot(tahoe_highrez_training_polygons,zcol="Class")
tahoe_highrez_training_points <- readOGR(dsn=system.file("external", package="spatial.tools"),layer="tahoe_highrez_training_points")
spplot(tahoe_highrez_training_points,zcol="SPECIES")
tahoe_highrez_training_points_utm <- readOGR(dsn=system.file("external", package="spatial.tools"),layer="tahoe_highrez_training_points_utm")
print(projection(tahoe_highrez_training_points_utm))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{tahoe\_lidar\_bareearth.tif}{Lidar-derived bare earth digital elevation model from the Lake Tahoe Basin.}{tahoe.Rul.lidar.Rul.bareearth.tif}
\keyword{data}{tahoe\_lidar\_bareearth.tif}
\keyword{datasets}{tahoe\_lidar\_bareearth.tif}
%
\begin{Description}\relax
Lidar-derived bare earth digital elevation model from the
Lake Tahoe Basin.
\end{Description}
%
\begin{Author}\relax
Jonathan A. Greenberg \email{spatial.tools@estarcion.net}
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
tahoe_lidar_bareearth <- raster(system.file("external/tahoe_lidar_bareearth.tif", package="spatial.tools"))
plot(tahoe_lidar_bareearth)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{tahoe\_lidar\_highesthit.tif}{Lidar-derived highest hit (aka canopy) digital elevation model from the Lake Tahoe Basin.}{tahoe.Rul.lidar.Rul.highesthit.tif}
\keyword{data}{tahoe\_lidar\_highesthit.tif}
\keyword{datasets}{tahoe\_lidar\_highesthit.tif}
%
\begin{Description}\relax
Lidar-derived highest hit (aka canopy) digital elevation
model from the Lake Tahoe Basin.
\end{Description}
%
\begin{Author}\relax
Jonathan A. Greenberg \email{spatial.tools@estarcion.net}
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
tahoe_lidar_highesthit <- raster(system.file("external/tahoe_lidar_highesthit.tif", package="spatial.tools"))
plot(tahoe_lidar_highesthit)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{which.max.simple}{Location of Maximum Value}{which.max.simple}
\keyword{calculate}{which.max.simple}
%
\begin{Description}\relax
Locates the largest value of the input object.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  which.max.simple(x, na.rm = TRUE, tie_value = "NA")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a numeric object

\item[\code{na.rm}] a logical indicating whether missing values
should be removed.

\item[\code{tie\_value}] A character indicating how to deal with
ties.  Can be "NA" (returns an NA if a tie is found) or
"random" (returns a single randomly chosen member of the
ties if a tie is found) or "first" (returns the first
class found).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An integer of length 1 giving the index of the maximum of
x or NA if the maximum of x is not unique, x has no
non-NAs, or na.rm=F.
\end{Value}
%
\begin{Author}\relax
Jonathan A. Greenberg, Alison R. Mynsberge
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{which.max}{which.max}}, \code{\LinkA{which}{which}},
\code{\LinkA{max}{max}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 

x<-c(2:4,1,1,NA)
y<-c(4,1:3,NA,4)
## The index is only calculated for a unique maximum
which.max.simple(x)
which.max.simple(y)
which.max.simple(y,na.rm=FALSE)
which.max.simple(x,na.rm=FALSE)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{which.min.simple}{Location of Minimum Value}{which.min.simple}
\keyword{calculate}{which.min.simple}
%
\begin{Description}\relax
Locates the smallest value of the input object.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  which.min.simple(x, na.rm = TRUE, tie_value = "NA")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a numeric object

\item[\code{na.rm}] a logical indicating whether missing values
should be removed.

\item[\code{tie\_value}] A character indicating how to deal with
ties.  Can be "NA" (returns an NA if a tie is found) or
"random" (returns a single randomly chosen member of the
ties if a tie is found) or "first" (returns the first
class found).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An integer of length 1 giving the index of the minimum of
x or NA if the minimum of x is not unique, x has no
non-NAs, or na.rm=F.
\end{Value}
%
\begin{Author}\relax
Jonathan A. Greenberg, Alison R. Mynsberge
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{which.min}{which.min}}, \code{\LinkA{which}{which}},
\code{\LinkA{min}{min}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 

x<-c(4,1:3,NA,4)
y<-c(2:4,1,1,NA)
## The index is only calculated for a unique minimum
which.min.simple(x)
which.min.simple(y)
which.min.simple(y,na.rm=FALSE)
which.min.simple(x,na.rm=FALSE)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
